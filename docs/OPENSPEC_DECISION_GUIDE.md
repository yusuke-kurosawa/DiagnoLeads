# OpenSpec 使用判断ガイド

**目的**: 変更を行う際に、OpenSpecワークフローを使うべきか、直接編集すべきかを素早く判断するためのガイド

---

## 🚦 クイック判断フローチャート

```
変更を行いたい
    ↓
    ├─ 機能追加・変更？ ──→ YES ──→ ✅ OpenSpec使用
    │
    ├─ API仕様変更？ ──→ YES ──→ ✅ OpenSpec使用
    │
    ├─ データベース変更？ ──→ YES ──→ ✅ OpenSpec使用
    │
    ├─ セキュリティ関連？ ──→ YES ──→ ✅ OpenSpec使用
    │
    ├─ アーキテクチャ変更？ ──→ YES ──→ ✅ OpenSpec使用
    │
    └─ 上記以外（ドキュメント、UI微調整、軽微なバグ修正など）
        ↓
        ❌ 直接編集でOK
```

---

## ✅ OpenSpecを使うべき変更（仕様駆動が必要）

### 1️⃣ 新機能の追加

**例:**
- AI診断生成機能
- Microsoft Teams統合
- LINE連携
- リアルタイムコラボレーション

**なぜ?**
- 仕様の明確化が必須
- レビューと合意が必要
- 後から参照できる仕様書が重要

**ワークフロー:**
```bash
/openspec-proposal "Teams統合機能を追加"
# → 仕様ファイル生成 → レビュー → /openspec-apply → 実装 → /openspec-archive
```

---

### 2️⃣ 既存機能の大幅な変更

**例:**
- 認証フローの変更
- スコアリングロジックの変更
- データモデルの変更

**なぜ?**
- 影響範囲が大きい
- 破壊的変更の可能性
- 他の開発者への影響

---

### 3️⃣ API仕様の変更・追加

**例:**
- 新しいエンドポイント追加
- リクエスト/レスポンス形式変更
- パラメータ追加・削除

**なぜ?**
- 外部インターフェース変更
- フロントエンド・バックエンド間の契約
- API仕様書の自動更新が必要

**重要:**
- OpenAPIスキーマも自動生成される
- 仕様変更がOpenAPI仕様に反映される

---

### 4️⃣ データベーススキーマ変更

**例:**
- テーブル追加・削除
- カラム追加・変更
- インデックス追加
- リレーションシップ変更

**なぜ?**
- マイグレーション計画が必要
- データ整合性の確保
- ロールバック手順の明確化

---

### 5️⃣ セキュリティ関連の変更

**例:**
- 認可ロジック変更
- 暗号化方式変更
- アクセス制御変更

**なぜ?**
- セキュリティは仕様レベルでのレビューが必須
- 脆弱性のリスク
- コンプライアンス要件

---

## ❌ 直接編集でOKな変更（迅速性優先）

### 1️⃣ ドキュメントの修正・更新

**例:**
- README.md更新
- セットアップガイド修正
- コメント追加
- ドキュメントのタイポ修正

**なぜ?**
- コードに影響しない
- 迅速な更新が優先
- レビューは通常のPRで十分

**例:**
```bash
vim README.md
git add README.md
git commit -m "docs: Update installation instructions"
git push
```

---

### 2️⃣ 軽微なバグ修正

**例:**
- タイポ修正
- 簡単なバリデーション追加
- null チェック追加
- エッジケースの対応

**なぜ?**
- 仕様変更を伴わない
- 影響範囲が小さい
- 迅速な修正が優先

**注意:**
複雑なバグ修正で仕様変更が必要な場合はOpenSpec使用

---

### 3️⃣ UI/UXの微調整

**例:**
- ボタンの位置調整
- 色変更
- フォントサイズ変更
- スペーシング調整
- アニメーション追加

**なぜ?**
- 視覚的な調整のみ
- 機能仕様に影響しない
- デザイナーとの素早い連携が必要

**境界線:**
- UIコンポーネント追加 → OpenSpec使用
- 既存コンポーネントの微調整 → 直接編集でOK

---

### 4️⃣ ログ・エラーメッセージの改善

**例:**
- より詳細なログ出力
- ユーザーフレンドリーなエラー文言
- デバッグ情報追加
- エラーハンドリング改善

**なぜ?**
- 機能変更ではない
- 開発者体験・ユーザー体験の向上
- 迅速な改善が優先

---

### 5️⃣ テストの追加・修正

**例:**
- 単体テスト追加
- テストデータ更新
- テストケース追加
- テストの修正

**なぜ?**
- 既存仕様のカバレッジ向上
- 品質向上が目的
- 仕様変更を伴わない

**注意:**
新しいテスト戦略の導入（E2Eテスト基盤など）はOpenSpec使用

---

### 6️⃣ パフォーマンス最適化（仕様変更なし）

**例:**
- SQLクエリ最適化
- キャッシュ追加
- N+1問題の解決
- インデックス追加（既存テーブル）

**なぜ?**
- 外部インターフェースに変更なし
- パフォーマンス改善のみ
- 迅速な対応が優先

**境界線:**
- 既存機能の最適化 → 直接編集でOK
- アーキテクチャ変更を伴う最適化 → OpenSpec使用

---

## 🤔 判断に迷ったら

### 4つの質問

1. **この変更は外部に影響しますか？**
   - API、データモデル、外部連携など
   - YES → ✅ OpenSpec使用

2. **複数のファイル・モジュールに影響しますか？**
   - フロントエンド + バックエンド
   - 複数のサービス
   - YES → ✅ OpenSpec使用

3. **他の開発者とレビュー・議論が必要ですか？**
   - 仕様レベルでの議論
   - 設計の選択肢の検討
   - YES → ✅ OpenSpec使用

4. **後から仕様を参照する必要がありますか？**
   - 「なぜこの設計にしたのか」を記録したい
   - 新しいメンバーが参照する
   - YES → ✅ OpenSpec使用

### 迷ったら...

**OpenSpecを使う方が安全です！**

理由:
- 仕様が残る = ドキュメントとして価値がある
- レビューの質が上がる
- 後から「なぜ」がわかる

---

## 📊 実際の判断例（10ケース）

| # | 変更内容 | OpenSpec | 理由 |
|---|---------|----------|------|
| 1 | Teams統合機能追加 | ✅ 使用 | 新機能、API追加、外部連携 |
| 2 | README.mdの修正 | ❌ 直接編集 | ドキュメント更新のみ |
| 3 | 認証ロジック変更 | ✅ 使用 | セキュリティ、仕様変更 |
| 4 | ボタン色変更 | ❌ 直接編集 | UI微調整 |
| 5 | 新エンドポイント追加 | ✅ 使用 | API仕様変更 |
| 6 | タイポ修正 | ❌ 直接編集 | 軽微なバグ修正 |
| 7 | DBスキーマ変更 | ✅ 使用 | アーキテクチャ変更 |
| 8 | テストケース追加 | ❌ 直接編集 | 既存仕様のカバレッジ向上 |
| 9 | エラーメッセージ改善 | ❌ 直接編集 | UX改善、機能変更なし |
| 10 | A/Bテスト機能追加 | ✅ 使用 | 新機能、複数モジュール影響 |

---

## 🎯 まとめ

### OpenSpecを使う基準（SIMPLE）

- **S**ignificant change（重要な変更）
- **I**nterface change（インターフェース変更）
- **M**ulti-module impact（複数モジュール影響）
- **P**lanning required（計画が必要）
- **L**ong-term reference（長期的に参照する）
- **E**xternal impact（外部影響）

**1つでも当てはまれば OpenSpec 使用！**

### 直接編集でOKな基準（QUICK）

- **Q**uick fix（迅速な修正）
- **U**I tweak only（UI微調整のみ）
- **I**nternal only（内部のみの変更）
- **C**osmetic change（見た目の変更）
- **K**nown scope（影響範囲が明確で小さい）

**すべて当てはまれば 直接編集でOK！**

---

## 📚 関連ドキュメント

- [CLAUDE.md](../CLAUDE.md) - 開発ガイドライン全体
- [OpenSpec公式ドキュメント](https://openspec.dev/)
- [プロジェクト概要](../openspec/specs/OVERVIEW.md)

---

**Built with ❤️ using OpenSpec Spec-Driven Development**
